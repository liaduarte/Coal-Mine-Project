# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CoalMine
                                 A QGIS plugin
 This plugin presents the database of Coal Mine Project.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-17
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Duarte et al
        email                : liaduarte@fc.up.pt
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QFileInfo
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.gui import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .coal_mine_dialog import CoalMineDialog
from .terrain import Ui_Terrain
from .years import Ui_Dialog
from .years_soil import Ui_Dialog
from .years_temp import Ui_Dialog
from .years_dem import Ui_Dialog
from .years_lulc import Ui_Dialog
from .kmeans import Ui_kmeans
import os.path

SYS_DIR  = "C:/OSGeo4W64/apps"
QGIS_DIR = os.path.join(SYS_DIR, 'qgis')


class CoalMine:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CoalMine_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Coal Mine')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.window = None
        self.window2 = None
        self.window3 = None
        self.window4 = None
        self.window5 = None
        self.terrain_analysis = None
        self.kmeans = None
        self.interpolation = None
        self.dlg = CoalMineDialog()
        self.dlg.setGeometry(100, 100, 1400, 800)

        # actions for File menu
        self.actionAddRasterLayer = self.dlg.menu_File.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Add Raster Layer"),
            self.AddRaster)
        self.actionAddVectorLayer = self.dlg.menu_File.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Add Vector Layer"),
            self.AddVector)

        # actions for Water menu
        self.actionAddcampanha_um = self.dlg.menu_Water.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Campaigns"),
            self.Addcampanha_water)

        # actions for Soil menu
        self.actionAddcampanha_um_solo = self.dlg.menu_Soil.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Campaigns"),
            self.Addcampanha_solo)

        # actions for Temperature menu points
        self.actionAddcampanha_um_temp_points = self.dlg.menu_Temperature.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Open temperature points"),
            self.Addcampanha_temp_maps_points)

        # actions for Temperature menu raster
        self.actionAddcampanha_um_temp_maps = self.dlg.menuTemp.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Campaigns"),
            self.Addcampanha_temp_maps)

        # actions for DEM
        self.actionAddDEM = self.dlg.menuDEM.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("DEM"),
            self.AddDEM)
        self.actionAddDEM_terrainanalysis = self.dlg.menuDEM.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Terrain Analysis"),
            self.AddDEM_terrainanalysis)

        # actions for LULC
        self.actionAddLULC = self.dlg.menuLULC.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("LULC"),
            self.AddLULC)
        self.actionAddLULC_class = self.dlg.menuLULC.addAction(
            QIcon(":/plugins/coal_mine/icon.png"), self.tr("Unsupervised Classification"),
            self.AddLULC_class)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CoalMine', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/coal_mine/coalmine4.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Coal Mine'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Coal Mine'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

        # show the dialog
        self.dlg.show()


    # File menu
    def AddVector(self):

        file = QFileDialog.getOpenFileName(self.dlg, "Open shapefile", ".", "Shp (*.shp)")
        fileInfo = QFileInfo(file)
        layer = QgsVectorLayer(file, fileInfo.fileName(), "ogr")
        QgsProject.instance().addMapLayer(layer)
        self.canvas.setExtent(layer.extent())

    def AddRaster(self):
        file = QFileDialog.getOpenFileName(self.dlg, "Open raster", ".", "Images(*.tif *.png *.jpg *.jpeg *.img)")
        fileInfo = QFileInfo(file)

        # add the raster
        layer = QgsRasterLayer(file, fileInfo.fileName(), "gdal")

        # add layer to the registry
        QgsProject.instance().addMapLayer(layer)

        # set extent to the extent of our layer
        self.canvas.setExtent(layer.extent())

        # set the map canvas layer set
        self.canvas.setLayerSet([QgsMapCanvasLayer(layer)])

    # water campanha 1
    def Addcampanha_water(self):

        if self.window is None:
            self.window = Window()
        self.window.comboBox.addItems(['2019', '2020', '2021'])
        self.window.show()
        self.window.pushButton.clicked.connect(self.define_year)
        self.window.pushButton_2.clicked.connect(self.close)

    def define_year(self):
        if self.window.comboBox.currentText()=='2019':
            # display file in canvas
            fileCI = QGIS_DIR + '/python/plugins/coal_mine/Pontos_de_Amostragem_de_Água.shp'
            #QMessageBox.about(self.dlg, "Fissured", str(fileCI))

            # vector layer
            vfileInfo = QFileInfo(fileCI)
            vlayer = QgsVectorLayer(fileCI, 'Pontos_de_Amostragem_de_Água', "ogr")

            QgsProject.instance().addMapLayer(vlayer)
            #QMessageBox.about(self.dlg, "Fissured", str('um'))
            self.canvas.setExtent(vlayer.extent())
            self.canvas.setLayers([layer])

        if self.window.comboBox.currentText() == '2020':
            QMessageBox.about(self.window, 'teste', '2020')
        if self.window.comboBox.currentText() == '2021':
            QMessageBox.about(self.window, 'teste', '2021')
        # water campanha 1

    def Addcampanha_solo(self):

        if self.window2 is None:
            self.window2 = Window2()
        self.window2.comboBox.addItems(['2019', '2020', '2021'])
        self.window2.show()
        self.window2.pushButton.clicked.connect(self.define_year_soils)
        self.window2.pushButton_2.clicked.connect(self.close)

    def define_year_soils(self):
        if self.window2.comboBox.currentText() == '2019':
            # display file in canvas
            fileCI = QGIS_DIR + '/python/plugins/coal_mine/Base_dados_solos.shp'
            file_info_norm = QFileInfo(str(fileCI))
            # vector layer
            vlayer = QgsVectorLayer(fileCI, file_info_norm.fileName(), 'ogr')

            if not vlayer.isValid():
                return
            QgsProject.instance().addMapLayer(vlayer)
            #self.canvas.setExtent(vlayer.extent())
        if self.window2.comboBox.currentText() == '2020':
            QMessageBox.about(self.window2, 'teste', '2020')
        if self.window2.comboBox.currentText() == '2021':
            QMessageBox.about(self.window2, 'teste', '2021')

    def Addcampanha_temp_maps_points(self):

        fileCI = QGIS_DIR + '/python/plugins/coal_mine/Pontos_Térmica.shp'

        # add the raster
        layer = QgsVectorLayer(fileCI, 'Temperature points', "ogr")

        # add layer to the registry
        QgsProject.instance().addMapLayer(layer)


    def Addcampanha_temp_maps (self):

        if self.window3 is None:
            self.window3 = Window3()
        self.window3.comboBox.addItems(['2019', '2020', '2021'])
        self.window3.show()
        self.window3.pushButton.clicked.connect(self.define_year_temp)
        self.window3.pushButton_2.clicked.connect(self.close)

    def define_year_temp(self):
        if self.window3.comboBox.currentText() == '2019':
            fileCI = QGIS_DIR + '/python/plugins/coal_mine/Thermal orthomosaic_10 november.tif'
            # add the raster
            layer = QgsRasterLayer(fileCI, 'Thermal_image', "gdal")
            # add layer to the registry
            QgsProject.instance().addMapLayer(layer)
            self.canvas.setExtent(layer.extent())
            self.canvas.setLayers([layer])
        if self.window3.comboBox.currentText() == '2020':
            QMessageBox.about(self.window3, 'teste', '2020')
        if self.window3.comboBox.currentText() == '2021':
            QMessageBox.about(self.window3, 'teste', '2021')


    def AddDEM_terrainanalysis(self):
        if self.terrain_analysis is None:
            self.terrain_analysis= Terrain_analysis()
        self.terrain_analysis.show()
        self.terrain_analysis.pushButton.clicked.connect(self.fillInputDEM)
        self.terrain_analysis.pushButton_2.clicked.connect(self.filloutSlope)
        self.terrain_analysis.pushButton_3.clicked.connect(self.filloutAspect)
        self.terrain_analysis.pushButton_4.clicked.connect(self.terrain_analysis_run)
        self.terrain_analysis.pushButton_5.clicked.connect(self.close)

    def AddDEM(self):

        if self.window4 is None:
            self.window4 = Window4()
        self.window4.comboBox.addItems(['2019', '2020', '2021'])
        self.window4.show()
        self.window4.pushButton.clicked.connect(self.define_year_dem)
        self.window4.pushButton_2.clicked.connect(self.close)

    def define_year_dem(self):
        if self.window4.comboBox.currentText() == '2019':
            fileCI = QGIS_DIR + '/python/plugins/coal_mine/dsm_area_nov1.tif'
            # add the raster
            layer = QgsRasterLayer(fileCI, 'DEM', "gdal")
            # add layer to the registry
            QgsProject.instance().addMapLayer(layer)
            self.canvas.setExtent(layer.extent())
            self.canvas.setLayers([layer])
        if self.window4.comboBox.currentText() == '2020':
            QMessageBox.about(self.window4, 'teste', '2020')
        if self.window4.comboBox.currentText() == '2021':
            QMessageBox.about(self.window4, 'teste', '2021')

    def AddLULC(self):
        if self.window5 is None:
            self.window5 = Window5()
        self.window5.comboBox.addItems(['2019', '2020', '2021'])
        self.window5.show()
        self.window5.pushButton.clicked.connect(self.define_year_lulc)
        self.window5.pushButton_2.clicked.connect(self.close)

    def define_year_lulc(self):
        if self.window5.comboBox.currentText() == '2019':
            fileCI = QGIS_DIR + '/python/plugins/coal_mine/_NOV_kmeans_RGBNIR.tif'
            # add the raster
            layer = QgsRasterLayer(fileCI, 'LULC', "gdal")
            # add layer to the registry
            QgsProject.instance().addMapLayer(layer)
            self.canvas.setExtent(layer.extent())
            self.canvas.setLayers([layer])
        if self.window5.comboBox.currentText() == '2020':
            QMessageBox.about(self.window5, 'teste', '2020')
        if self.window5.comboBox.currentText() == '2021':
            QMessageBox.about(self.window5, 'teste', '2021')

    def AddLULC_class(self):
        if self.kmeans is None:
            self.kmeans = Kmeans()
        self.kmeans.show()
        self.kmeans.pushButton.clicked.connect(self.fillInputDEM_kmeans)
        self.kmeans.pushButton_2.clicked.connect(self.filloutKmeans)
        self.kmeans.pushButton_3.clicked.connect(self.kmeans_run)
        self.kmeans.pushButton_4.clicked.connect(self.close)

    def close(self):
        self.window.close()

    # INPUT MDT
    def fillInputDEM(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select Input DEM ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.terrain_analysis.lineEdit.addItem(filename)

    def fillInputDEM_kmeans(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select Input DEM ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.kmeans.lineEdit.addItem(filename)

    # OUTPUT RASTER FILE
    def filloutSlope(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.terrain_analysis.lineEdit_4.setText(filename)

    # OUTPUT RASTER FILE
    def filloutAspect(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.terrain_analysis.lineEdit_5.setText(filename)

    def filloutKmeans(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.kmeans.lineEdit_2.setText(filename)

    def terrain_analysis_run(self):
        gdal.AllRegister()
        inputLayer_dem = self.lineEdit.currentText()
        gdalRaster = gdal.Open(str(inputLayer_dem))
        x = gdalRaster.RasterXSize
        y = gdalRaster.RasterYSize
        geo = gdalRaster.GetGeoTransform()
        minx = geo[0]
        maxy = geo[3]
        maxx = minx + geo[1] * x
        miny = maxy + geo[5] * y
        extent_raster = str(minx) + "," + str(maxx) + "," + str(miny) + "," + str(maxy)
        pixelSize = geo[1]

        outSlope = self.lineEdit_4.text()
        outAspect = self.lineEdit_5.text()

        # pixel size is the same as the dem raster, miss reamostragem

        Processing.initialize()

        # slope and aspect from DEM
        Processing.runAlgorithm("grass7:r.slope.aspect",
                            {'elevation': inputLayer_dem, 'format': 1, 'precision': 0,
                             '-a': True, 'zscale': 1, 'min_slope': 0,
                             'slope': outSlope,
                             'aspect': outAspect,
                             'pcurvature': None,
                             'tcurvature': None,
                             'dx': None,
                             'dy': None,
                             'dxx': None,
                             'dyy': None,
                             'dxy': None,
                             'GRASS_REGION_PARAMETER': extent_raster + '[EPSG:3763]',
                             'GRASS_REGION_CELLSIZE_PARAMETER': pixelSize, 'GRASS_RASTER_FORMAT_OPT': '',
                             'GRASS_RASTER_FORMAT_META': ''})

        # add result into canvas
        file_info_slope = QFileInfo(str(outSlope))
        file_info_aspect = QFileInfo(str(outAspect))
        slope = QgsRasterLayer(outSlope, file_info_slope.fileName(), 'gdal')
        aspect = QgsRasterLayer(outSlope, file_info_aspect.fileName(), 'gdal')
        self.layers = []
        rlayerslope = QgsRasterLayer(slope, "my_layer", "ogr")
        rlayeraspect = QgsRasterLayer(aspect, "my_layer", "ogr")

        self.layers.append(rlayerslope)
        self.layers.append(rlayeraspect)

        if rlayer.isValid():
            self.widget.setLayers(self.layers)
            self.widget.waitWhileRendering()
            self.widget.setExtent(rlayer.extent())
            self.widget.refresh()
        else:
            print("Layer not valid")

    def kmeans_run(self):
        inputLayer_dem = self.kmeans.lineEdit.currentText()
        outputLayer_kmeans = self.kmeans.lineEdit_2.currentText()
        cluster_value = self.kmeans.spinBox.value()
        Processing.runAlgorithm("saga:kmeansclusteringforgrids",
                       {'GRIDS': [str(inputLayer_dem)], 'METHOD': 1,
                        'NCLUSTER': str(cluster_value), 'MAXITER': 0, 'NORMALISE': False, 'OLDVERSION': False, 'UPDATEVIEW': True,
                        'CLUSTER': 'TEMPORARY_OUTPUT', 'STATISTICS': str(outputLayer_kmeans)})


class Window(QWidget, Ui_Dialog):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)

class Window2(QWidget, Ui_Dialog):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)

class Window3(QWidget, Ui_Dialog):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)

class Window4(QWidget, Ui_Dialog):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)

class Window5(QWidget, Ui_Dialog):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)

class Terrain_analysis(QWidget, Ui_Terrain):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)

class Kmeans(QWidget, Ui_kmeans):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)
